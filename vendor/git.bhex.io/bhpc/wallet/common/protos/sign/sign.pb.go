// Code generated by protoc-gen-go. DO NOT EDIT.
// source: sign.proto

package sign

import (
	fmt "fmt"

	proto "github.com/golang/protobuf/proto"

	math "math"

	common "git.bhex.io/bhpc/wallet/common/protos/common"

	core "git.bhex.io/bhpc/wallet/common/protos/token/tron/core"

	context "golang.org/x/net/context"

	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type TronSignReply struct {
	Code                 common.ReturnCode `protobuf:"varint,1,opt,name=code,proto3,enum=common.ReturnCode" json:"code,omitempty"`
	Msg                  string            `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	SignedTx             *core.Transaction `protobuf:"bytes,3,opt,name=signedTx,proto3" json:"signedTx,omitempty"`
	Extension            map[string]string `protobuf:"bytes,4,rep,name=extension,proto3" json:"extension,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TronSignReply) Reset()         { *m = TronSignReply{} }
func (m *TronSignReply) String() string { return proto.CompactTextString(m) }
func (*TronSignReply) ProtoMessage()    {}
func (*TronSignReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_sign_39209a8238778a81, []int{0}
}
func (m *TronSignReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TronSignReply.Unmarshal(m, b)
}
func (m *TronSignReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TronSignReply.Marshal(b, m, deterministic)
}
func (dst *TronSignReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TronSignReply.Merge(dst, src)
}
func (m *TronSignReply) XXX_Size() int {
	return xxx_messageInfo_TronSignReply.Size(m)
}
func (m *TronSignReply) XXX_DiscardUnknown() {
	xxx_messageInfo_TronSignReply.DiscardUnknown(m)
}

var xxx_messageInfo_TronSignReply proto.InternalMessageInfo

func (m *TronSignReply) GetCode() common.ReturnCode {
	if m != nil {
		return m.Code
	}
	return common.ReturnCode_SUCCESS
}

func (m *TronSignReply) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *TronSignReply) GetSignedTx() *core.Transaction {
	if m != nil {
		return m.SignedTx
	}
	return nil
}

func (m *TronSignReply) GetExtension() map[string]string {
	if m != nil {
		return m.Extension
	}
	return nil
}

type TronSignRequest struct {
	FromAddr             string            `protobuf:"bytes,1,opt,name=fromAddr,proto3" json:"fromAddr,omitempty"`
	PartedPK             []byte            `protobuf:"bytes,2,opt,name=partedPK,proto3" json:"partedPK,omitempty"`
	Tx                   *core.Transaction `protobuf:"bytes,3,opt,name=Tx,proto3" json:"Tx,omitempty"`
	Extension            map[string]string `protobuf:"bytes,4,rep,name=extension,proto3" json:"extension,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TronSignRequest) Reset()         { *m = TronSignRequest{} }
func (m *TronSignRequest) String() string { return proto.CompactTextString(m) }
func (*TronSignRequest) ProtoMessage()    {}
func (*TronSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_sign_39209a8238778a81, []int{1}
}
func (m *TronSignRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TronSignRequest.Unmarshal(m, b)
}
func (m *TronSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TronSignRequest.Marshal(b, m, deterministic)
}
func (dst *TronSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TronSignRequest.Merge(dst, src)
}
func (m *TronSignRequest) XXX_Size() int {
	return xxx_messageInfo_TronSignRequest.Size(m)
}
func (m *TronSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TronSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TronSignRequest proto.InternalMessageInfo

func (m *TronSignRequest) GetFromAddr() string {
	if m != nil {
		return m.FromAddr
	}
	return ""
}

func (m *TronSignRequest) GetPartedPK() []byte {
	if m != nil {
		return m.PartedPK
	}
	return nil
}

func (m *TronSignRequest) GetTx() *core.Transaction {
	if m != nil {
		return m.Tx
	}
	return nil
}

func (m *TronSignRequest) GetExtension() map[string]string {
	if m != nil {
		return m.Extension
	}
	return nil
}

type EthLikeSignRequest struct {
	From                 string            `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To                   string            `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Amount               string            `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Nonce                uint64            `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	GasPrice             uint64            `protobuf:"varint,5,opt,name=gasPrice,proto3" json:"gasPrice,omitempty"`
	PrivateKey           []byte            `protobuf:"bytes,6,opt,name=privateKey,proto3" json:"privateKey,omitempty"`
	TokenId              string            `protobuf:"bytes,7,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	ChainId              string            `protobuf:"bytes,8,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Extension            map[string]string `protobuf:"bytes,9,rep,name=extension,proto3" json:"extension,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EthLikeSignRequest) Reset()         { *m = EthLikeSignRequest{} }
func (m *EthLikeSignRequest) String() string { return proto.CompactTextString(m) }
func (*EthLikeSignRequest) ProtoMessage()    {}
func (*EthLikeSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_sign_39209a8238778a81, []int{2}
}
func (m *EthLikeSignRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EthLikeSignRequest.Unmarshal(m, b)
}
func (m *EthLikeSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EthLikeSignRequest.Marshal(b, m, deterministic)
}
func (dst *EthLikeSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthLikeSignRequest.Merge(dst, src)
}
func (m *EthLikeSignRequest) XXX_Size() int {
	return xxx_messageInfo_EthLikeSignRequest.Size(m)
}
func (m *EthLikeSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_EthLikeSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_EthLikeSignRequest proto.InternalMessageInfo

func (m *EthLikeSignRequest) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *EthLikeSignRequest) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *EthLikeSignRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EthLikeSignRequest) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *EthLikeSignRequest) GetGasPrice() uint64 {
	if m != nil {
		return m.GasPrice
	}
	return 0
}

func (m *EthLikeSignRequest) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *EthLikeSignRequest) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func (m *EthLikeSignRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *EthLikeSignRequest) GetExtension() map[string]string {
	if m != nil {
		return m.Extension
	}
	return nil
}

type EthLikeSignReply struct {
	Code                 common.ReturnCode `protobuf:"varint,1,opt,name=code,proto3,enum=common.ReturnCode" json:"code,omitempty"`
	Msg                  string            `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	SignedTx             []byte            `protobuf:"bytes,3,opt,name=signedTx,proto3" json:"signedTx,omitempty"`
	Extension            map[string]string `protobuf:"bytes,4,rep,name=extension,proto3" json:"extension,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *EthLikeSignReply) Reset()         { *m = EthLikeSignReply{} }
func (m *EthLikeSignReply) String() string { return proto.CompactTextString(m) }
func (*EthLikeSignReply) ProtoMessage()    {}
func (*EthLikeSignReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_sign_39209a8238778a81, []int{3}
}
func (m *EthLikeSignReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_EthLikeSignReply.Unmarshal(m, b)
}
func (m *EthLikeSignReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_EthLikeSignReply.Marshal(b, m, deterministic)
}
func (dst *EthLikeSignReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EthLikeSignReply.Merge(dst, src)
}
func (m *EthLikeSignReply) XXX_Size() int {
	return xxx_messageInfo_EthLikeSignReply.Size(m)
}
func (m *EthLikeSignReply) XXX_DiscardUnknown() {
	xxx_messageInfo_EthLikeSignReply.DiscardUnknown(m)
}

var xxx_messageInfo_EthLikeSignReply proto.InternalMessageInfo

func (m *EthLikeSignReply) GetCode() common.ReturnCode {
	if m != nil {
		return m.Code
	}
	return common.ReturnCode_SUCCESS
}

func (m *EthLikeSignReply) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *EthLikeSignReply) GetSignedTx() []byte {
	if m != nil {
		return m.SignedTx
	}
	return nil
}

func (m *EthLikeSignReply) GetExtension() map[string]string {
	if m != nil {
		return m.Extension
	}
	return nil
}

type Erc20LikeSignRequest struct {
	From                 string            `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
	To                   string            `protobuf:"bytes,2,opt,name=to,proto3" json:"to,omitempty"`
	Amount               string            `protobuf:"bytes,3,opt,name=amount,proto3" json:"amount,omitempty"`
	Nonce                uint64            `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	GasPrice             uint64            `protobuf:"varint,5,opt,name=gasPrice,proto3" json:"gasPrice,omitempty"`
	TokenAddress         string            `protobuf:"bytes,6,opt,name=tokenAddress,proto3" json:"tokenAddress,omitempty"`
	Decimals             uint64            `protobuf:"varint,7,opt,name=decimals,proto3" json:"decimals,omitempty"`
	PrivateKey           []byte            `protobuf:"bytes,8,opt,name=privateKey,proto3" json:"privateKey,omitempty"`
	TokenId              string            `protobuf:"bytes,9,opt,name=token_id,json=tokenId,proto3" json:"token_id,omitempty"`
	ChainId              string            `protobuf:"bytes,10,opt,name=chain_id,json=chainId,proto3" json:"chain_id,omitempty"`
	Extension            map[string]string `protobuf:"bytes,11,rep,name=extension,proto3" json:"extension,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Erc20LikeSignRequest) Reset()         { *m = Erc20LikeSignRequest{} }
func (m *Erc20LikeSignRequest) String() string { return proto.CompactTextString(m) }
func (*Erc20LikeSignRequest) ProtoMessage()    {}
func (*Erc20LikeSignRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_sign_39209a8238778a81, []int{4}
}
func (m *Erc20LikeSignRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Erc20LikeSignRequest.Unmarshal(m, b)
}
func (m *Erc20LikeSignRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Erc20LikeSignRequest.Marshal(b, m, deterministic)
}
func (dst *Erc20LikeSignRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Erc20LikeSignRequest.Merge(dst, src)
}
func (m *Erc20LikeSignRequest) XXX_Size() int {
	return xxx_messageInfo_Erc20LikeSignRequest.Size(m)
}
func (m *Erc20LikeSignRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_Erc20LikeSignRequest.DiscardUnknown(m)
}

var xxx_messageInfo_Erc20LikeSignRequest proto.InternalMessageInfo

func (m *Erc20LikeSignRequest) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

func (m *Erc20LikeSignRequest) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

func (m *Erc20LikeSignRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Erc20LikeSignRequest) GetNonce() uint64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *Erc20LikeSignRequest) GetGasPrice() uint64 {
	if m != nil {
		return m.GasPrice
	}
	return 0
}

func (m *Erc20LikeSignRequest) GetTokenAddress() string {
	if m != nil {
		return m.TokenAddress
	}
	return ""
}

func (m *Erc20LikeSignRequest) GetDecimals() uint64 {
	if m != nil {
		return m.Decimals
	}
	return 0
}

func (m *Erc20LikeSignRequest) GetPrivateKey() []byte {
	if m != nil {
		return m.PrivateKey
	}
	return nil
}

func (m *Erc20LikeSignRequest) GetTokenId() string {
	if m != nil {
		return m.TokenId
	}
	return ""
}

func (m *Erc20LikeSignRequest) GetChainId() string {
	if m != nil {
		return m.ChainId
	}
	return ""
}

func (m *Erc20LikeSignRequest) GetExtension() map[string]string {
	if m != nil {
		return m.Extension
	}
	return nil
}

type Erc20LikeSignReply struct {
	Code                 common.ReturnCode `protobuf:"varint,1,opt,name=code,proto3,enum=common.ReturnCode" json:"code,omitempty"`
	Msg                  string            `protobuf:"bytes,2,opt,name=msg,proto3" json:"msg,omitempty"`
	SignedTx             []byte            `protobuf:"bytes,3,opt,name=signedTx,proto3" json:"signedTx,omitempty"`
	Extension            map[string]string `protobuf:"bytes,4,rep,name=extension,proto3" json:"extension,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Erc20LikeSignReply) Reset()         { *m = Erc20LikeSignReply{} }
func (m *Erc20LikeSignReply) String() string { return proto.CompactTextString(m) }
func (*Erc20LikeSignReply) ProtoMessage()    {}
func (*Erc20LikeSignReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_sign_39209a8238778a81, []int{5}
}
func (m *Erc20LikeSignReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Erc20LikeSignReply.Unmarshal(m, b)
}
func (m *Erc20LikeSignReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Erc20LikeSignReply.Marshal(b, m, deterministic)
}
func (dst *Erc20LikeSignReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Erc20LikeSignReply.Merge(dst, src)
}
func (m *Erc20LikeSignReply) XXX_Size() int {
	return xxx_messageInfo_Erc20LikeSignReply.Size(m)
}
func (m *Erc20LikeSignReply) XXX_DiscardUnknown() {
	xxx_messageInfo_Erc20LikeSignReply.DiscardUnknown(m)
}

var xxx_messageInfo_Erc20LikeSignReply proto.InternalMessageInfo

func (m *Erc20LikeSignReply) GetCode() common.ReturnCode {
	if m != nil {
		return m.Code
	}
	return common.ReturnCode_SUCCESS
}

func (m *Erc20LikeSignReply) GetMsg() string {
	if m != nil {
		return m.Msg
	}
	return ""
}

func (m *Erc20LikeSignReply) GetSignedTx() []byte {
	if m != nil {
		return m.SignedTx
	}
	return nil
}

func (m *Erc20LikeSignReply) GetExtension() map[string]string {
	if m != nil {
		return m.Extension
	}
	return nil
}

func init() {
	proto.RegisterType((*TronSignReply)(nil), "sign.TronSignReply")
	proto.RegisterMapType((map[string]string)(nil), "sign.TronSignReply.ExtensionEntry")
	proto.RegisterType((*TronSignRequest)(nil), "sign.TronSignRequest")
	proto.RegisterMapType((map[string]string)(nil), "sign.TronSignRequest.ExtensionEntry")
	proto.RegisterType((*EthLikeSignRequest)(nil), "sign.EthLikeSignRequest")
	proto.RegisterMapType((map[string]string)(nil), "sign.EthLikeSignRequest.ExtensionEntry")
	proto.RegisterType((*EthLikeSignReply)(nil), "sign.EthLikeSignReply")
	proto.RegisterMapType((map[string]string)(nil), "sign.EthLikeSignReply.ExtensionEntry")
	proto.RegisterType((*Erc20LikeSignRequest)(nil), "sign.Erc20LikeSignRequest")
	proto.RegisterMapType((map[string]string)(nil), "sign.Erc20LikeSignRequest.ExtensionEntry")
	proto.RegisterType((*Erc20LikeSignReply)(nil), "sign.Erc20LikeSignReply")
	proto.RegisterMapType((map[string]string)(nil), "sign.Erc20LikeSignReply.ExtensionEntry")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// SignClient is the client API for Sign service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type SignClient interface {
	// UTXO模型的一类代币的签名接口
	UtxoSign(ctx context.Context, in *common.UtxoSignRequest, opts ...grpc.CallOption) (*common.UtxoSignReply, error)
	// 以账户余额模型的一类代币的签名接口
	EthSign(ctx context.Context, in *common.EthSignRequest, opts ...grpc.CallOption) (*common.EthSignReply, error)
	EtcSign(ctx context.Context, in *common.EthSignRequest, opts ...grpc.CallOption) (*common.EthSignReply, error)
	Erc20Sign(ctx context.Context, in *common.Erc20SignRequest, opts ...grpc.CallOption) (*common.Erc20SignReply, error)
	// UTXO 多签名
	UtxoMultiSign(ctx context.Context, in *common.UtxoMultiSignRequest, opts ...grpc.CallOption) (*common.UtxoMultiSignReply, error)
	EthMultiSign(ctx context.Context, in *common.EthMultiSignRequest, opts ...grpc.CallOption) (*common.EthMultiSignReply, error)
	Erc20MultiSign(ctx context.Context, in *common.Erc20MultiSignRequest, opts ...grpc.CallOption) (*common.Erc20MultiSignReply, error)
	// eos like
	EosLikeSign(ctx context.Context, in *common.EosLikeSignRequest, opts ...grpc.CallOption) (*common.EosLikeSignReply, error)
	EosLikeSingleSign(ctx context.Context, in *common.EosLikeSignRequest, opts ...grpc.CallOption) (*common.EosLikeSignReply, error)
	// tron
	TronSign(ctx context.Context, in *TronSignRequest, opts ...grpc.CallOption) (*TronSignReply, error)
	// Ripple  Sign
	RippleSign(ctx context.Context, in *common.RippleSignRequest, opts ...grpc.CallOption) (*common.RippleSignReply, error)
	RippleMultiSign(ctx context.Context, in *common.RippleMultiSignRequest, opts ...grpc.CallOption) (*common.RippleMultiSignReply, error)
	// Ont MultiSign
	OntSign(ctx context.Context, in *common.OntSignRequest, opts ...grpc.CallOption) (*common.OntSignReply, error)
	OntMultiSign(ctx context.Context, in *common.OntMultiSignRequest, opts ...grpc.CallOption) (*common.OntMultiSignReply, error)
	// VolumeSign volume single sign
	VolumeSign(ctx context.Context, in *common.VolumeSignRequest, opts ...grpc.CallOption) (*common.VolumeSignReply, error)
	// EthLikeSign chain forked from eth single sign
	EthLikeSign(ctx context.Context, in *EthLikeSignRequest, opts ...grpc.CallOption) (*EthLikeSignReply, error)
	// Erc20LikeSign chain forked from eth single sign for erc20 like tokens
	Erc20LikeSign(ctx context.Context, in *Erc20LikeSignRequest, opts ...grpc.CallOption) (*Erc20LikeSignReply, error)
	AtomSign(ctx context.Context, in *common.AtomSignRequest, opts ...grpc.CallOption) (*common.AtomSignReply, error)
	AtomMultiSign(ctx context.Context, in *common.AtomMultiSignRequest, opts ...grpc.CallOption) (*common.AtomMultiSignReply, error)
	BnbSign(ctx context.Context, in *common.AtomSignRequest, opts ...grpc.CallOption) (*common.AtomSignReply, error)
	BnbMultiSign(ctx context.Context, in *common.AtomMultiSignRequest, opts ...grpc.CallOption) (*common.AtomMultiSignReply, error)
	PocSign(ctx context.Context, in *common.AtomSignRequest, opts ...grpc.CallOption) (*common.AtomSignReply, error)
	PocMultiSign(ctx context.Context, in *common.AtomMultiSignRequest, opts ...grpc.CallOption) (*common.AtomMultiSignReply, error)
	MultiSignMsg(ctx context.Context, in *common.MultiSignMsgRequest, opts ...grpc.CallOption) (*common.MultiSignMsgReply, error)
	// Asch like Sign
	AschLikeSign(ctx context.Context, in *common.AschLikeSignRequest, opts ...grpc.CallOption) (*common.AschLikeSignReply, error)
	// IotexLikeSign iotex like Sign
	IotexLikeSign(ctx context.Context, in *common.IotexLikeSignRequest, opts ...grpc.CallOption) (*common.IotexLikeSignReply, error)
	// Xrc20LikeSign iotex token sign
	Xrc20LikeSign(ctx context.Context, in *common.Xrc20LikeSignRequest, opts ...grpc.CallOption) (*common.Xrc20LikeSignReply, error)
	XtzSign(ctx context.Context, in *common.XtzSignRequest, opts ...grpc.CallOption) (*common.XtzSignReply, error)
}

type signClient struct {
	cc *grpc.ClientConn
}

func NewSignClient(cc *grpc.ClientConn) SignClient {
	return &signClient{cc}
}

func (c *signClient) UtxoSign(ctx context.Context, in *common.UtxoSignRequest, opts ...grpc.CallOption) (*common.UtxoSignReply, error) {
	out := new(common.UtxoSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/UtxoSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) EthSign(ctx context.Context, in *common.EthSignRequest, opts ...grpc.CallOption) (*common.EthSignReply, error) {
	out := new(common.EthSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/EthSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) EtcSign(ctx context.Context, in *common.EthSignRequest, opts ...grpc.CallOption) (*common.EthSignReply, error) {
	out := new(common.EthSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/EtcSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) Erc20Sign(ctx context.Context, in *common.Erc20SignRequest, opts ...grpc.CallOption) (*common.Erc20SignReply, error) {
	out := new(common.Erc20SignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/Erc20Sign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) UtxoMultiSign(ctx context.Context, in *common.UtxoMultiSignRequest, opts ...grpc.CallOption) (*common.UtxoMultiSignReply, error) {
	out := new(common.UtxoMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/UtxoMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) EthMultiSign(ctx context.Context, in *common.EthMultiSignRequest, opts ...grpc.CallOption) (*common.EthMultiSignReply, error) {
	out := new(common.EthMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/EthMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) Erc20MultiSign(ctx context.Context, in *common.Erc20MultiSignRequest, opts ...grpc.CallOption) (*common.Erc20MultiSignReply, error) {
	out := new(common.Erc20MultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/Erc20MultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) EosLikeSign(ctx context.Context, in *common.EosLikeSignRequest, opts ...grpc.CallOption) (*common.EosLikeSignReply, error) {
	out := new(common.EosLikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/EosLikeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) EosLikeSingleSign(ctx context.Context, in *common.EosLikeSignRequest, opts ...grpc.CallOption) (*common.EosLikeSignReply, error) {
	out := new(common.EosLikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/EosLikeSingleSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) TronSign(ctx context.Context, in *TronSignRequest, opts ...grpc.CallOption) (*TronSignReply, error) {
	out := new(TronSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/TronSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) RippleSign(ctx context.Context, in *common.RippleSignRequest, opts ...grpc.CallOption) (*common.RippleSignReply, error) {
	out := new(common.RippleSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/RippleSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) RippleMultiSign(ctx context.Context, in *common.RippleMultiSignRequest, opts ...grpc.CallOption) (*common.RippleMultiSignReply, error) {
	out := new(common.RippleMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/RippleMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) OntSign(ctx context.Context, in *common.OntSignRequest, opts ...grpc.CallOption) (*common.OntSignReply, error) {
	out := new(common.OntSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/OntSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) OntMultiSign(ctx context.Context, in *common.OntMultiSignRequest, opts ...grpc.CallOption) (*common.OntMultiSignReply, error) {
	out := new(common.OntMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/OntMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) VolumeSign(ctx context.Context, in *common.VolumeSignRequest, opts ...grpc.CallOption) (*common.VolumeSignReply, error) {
	out := new(common.VolumeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/VolumeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) EthLikeSign(ctx context.Context, in *EthLikeSignRequest, opts ...grpc.CallOption) (*EthLikeSignReply, error) {
	out := new(EthLikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/EthLikeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) Erc20LikeSign(ctx context.Context, in *Erc20LikeSignRequest, opts ...grpc.CallOption) (*Erc20LikeSignReply, error) {
	out := new(Erc20LikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/Erc20LikeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) AtomSign(ctx context.Context, in *common.AtomSignRequest, opts ...grpc.CallOption) (*common.AtomSignReply, error) {
	out := new(common.AtomSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/AtomSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) AtomMultiSign(ctx context.Context, in *common.AtomMultiSignRequest, opts ...grpc.CallOption) (*common.AtomMultiSignReply, error) {
	out := new(common.AtomMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/AtomMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) BnbSign(ctx context.Context, in *common.AtomSignRequest, opts ...grpc.CallOption) (*common.AtomSignReply, error) {
	out := new(common.AtomSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/BnbSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) BnbMultiSign(ctx context.Context, in *common.AtomMultiSignRequest, opts ...grpc.CallOption) (*common.AtomMultiSignReply, error) {
	out := new(common.AtomMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/BnbMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) PocSign(ctx context.Context, in *common.AtomSignRequest, opts ...grpc.CallOption) (*common.AtomSignReply, error) {
	out := new(common.AtomSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/PocSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) PocMultiSign(ctx context.Context, in *common.AtomMultiSignRequest, opts ...grpc.CallOption) (*common.AtomMultiSignReply, error) {
	out := new(common.AtomMultiSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/PocMultiSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) MultiSignMsg(ctx context.Context, in *common.MultiSignMsgRequest, opts ...grpc.CallOption) (*common.MultiSignMsgReply, error) {
	out := new(common.MultiSignMsgReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/MultiSignMsg", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) AschLikeSign(ctx context.Context, in *common.AschLikeSignRequest, opts ...grpc.CallOption) (*common.AschLikeSignReply, error) {
	out := new(common.AschLikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/AschLikeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) IotexLikeSign(ctx context.Context, in *common.IotexLikeSignRequest, opts ...grpc.CallOption) (*common.IotexLikeSignReply, error) {
	out := new(common.IotexLikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/IotexLikeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) Xrc20LikeSign(ctx context.Context, in *common.Xrc20LikeSignRequest, opts ...grpc.CallOption) (*common.Xrc20LikeSignReply, error) {
	out := new(common.Xrc20LikeSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/Xrc20LikeSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *signClient) XtzSign(ctx context.Context, in *common.XtzSignRequest, opts ...grpc.CallOption) (*common.XtzSignReply, error) {
	out := new(common.XtzSignReply)
	err := c.cc.Invoke(ctx, "/sign.Sign/XtzSign", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SignServer is the server API for Sign service.
type SignServer interface {
	// UTXO模型的一类代币的签名接口
	UtxoSign(context.Context, *common.UtxoSignRequest) (*common.UtxoSignReply, error)
	// 以账户余额模型的一类代币的签名接口
	EthSign(context.Context, *common.EthSignRequest) (*common.EthSignReply, error)
	EtcSign(context.Context, *common.EthSignRequest) (*common.EthSignReply, error)
	Erc20Sign(context.Context, *common.Erc20SignRequest) (*common.Erc20SignReply, error)
	// UTXO 多签名
	UtxoMultiSign(context.Context, *common.UtxoMultiSignRequest) (*common.UtxoMultiSignReply, error)
	EthMultiSign(context.Context, *common.EthMultiSignRequest) (*common.EthMultiSignReply, error)
	Erc20MultiSign(context.Context, *common.Erc20MultiSignRequest) (*common.Erc20MultiSignReply, error)
	// eos like
	EosLikeSign(context.Context, *common.EosLikeSignRequest) (*common.EosLikeSignReply, error)
	EosLikeSingleSign(context.Context, *common.EosLikeSignRequest) (*common.EosLikeSignReply, error)
	// tron
	TronSign(context.Context, *TronSignRequest) (*TronSignReply, error)
	// Ripple  Sign
	RippleSign(context.Context, *common.RippleSignRequest) (*common.RippleSignReply, error)
	RippleMultiSign(context.Context, *common.RippleMultiSignRequest) (*common.RippleMultiSignReply, error)
	// Ont MultiSign
	OntSign(context.Context, *common.OntSignRequest) (*common.OntSignReply, error)
	OntMultiSign(context.Context, *common.OntMultiSignRequest) (*common.OntMultiSignReply, error)
	// VolumeSign volume single sign
	VolumeSign(context.Context, *common.VolumeSignRequest) (*common.VolumeSignReply, error)
	// EthLikeSign chain forked from eth single sign
	EthLikeSign(context.Context, *EthLikeSignRequest) (*EthLikeSignReply, error)
	// Erc20LikeSign chain forked from eth single sign for erc20 like tokens
	Erc20LikeSign(context.Context, *Erc20LikeSignRequest) (*Erc20LikeSignReply, error)
	AtomSign(context.Context, *common.AtomSignRequest) (*common.AtomSignReply, error)
	AtomMultiSign(context.Context, *common.AtomMultiSignRequest) (*common.AtomMultiSignReply, error)
	BnbSign(context.Context, *common.AtomSignRequest) (*common.AtomSignReply, error)
	BnbMultiSign(context.Context, *common.AtomMultiSignRequest) (*common.AtomMultiSignReply, error)
	PocSign(context.Context, *common.AtomSignRequest) (*common.AtomSignReply, error)
	PocMultiSign(context.Context, *common.AtomMultiSignRequest) (*common.AtomMultiSignReply, error)
	MultiSignMsg(context.Context, *common.MultiSignMsgRequest) (*common.MultiSignMsgReply, error)
	// Asch like Sign
	AschLikeSign(context.Context, *common.AschLikeSignRequest) (*common.AschLikeSignReply, error)
	// IotexLikeSign iotex like Sign
	IotexLikeSign(context.Context, *common.IotexLikeSignRequest) (*common.IotexLikeSignReply, error)
	// Xrc20LikeSign iotex token sign
	Xrc20LikeSign(context.Context, *common.Xrc20LikeSignRequest) (*common.Xrc20LikeSignReply, error)
	XtzSign(context.Context, *common.XtzSignRequest) (*common.XtzSignReply, error)
}

func RegisterSignServer(s *grpc.Server, srv SignServer) {
	s.RegisterService(&_Sign_serviceDesc, srv)
}

func _Sign_UtxoSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.UtxoSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).UtxoSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/UtxoSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).UtxoSign(ctx, req.(*common.UtxoSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_EthSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.EthSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).EthSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/EthSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).EthSign(ctx, req.(*common.EthSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_EtcSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.EthSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).EtcSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/EtcSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).EtcSign(ctx, req.(*common.EthSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_Erc20Sign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Erc20SignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).Erc20Sign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/Erc20Sign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).Erc20Sign(ctx, req.(*common.Erc20SignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_UtxoMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.UtxoMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).UtxoMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/UtxoMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).UtxoMultiSign(ctx, req.(*common.UtxoMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_EthMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.EthMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).EthMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/EthMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).EthMultiSign(ctx, req.(*common.EthMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_Erc20MultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Erc20MultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).Erc20MultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/Erc20MultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).Erc20MultiSign(ctx, req.(*common.Erc20MultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_EosLikeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.EosLikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).EosLikeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/EosLikeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).EosLikeSign(ctx, req.(*common.EosLikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_EosLikeSingleSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.EosLikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).EosLikeSingleSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/EosLikeSingleSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).EosLikeSingleSign(ctx, req.(*common.EosLikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_TronSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TronSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).TronSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/TronSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).TronSign(ctx, req.(*TronSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_RippleSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RippleSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).RippleSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/RippleSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).RippleSign(ctx, req.(*common.RippleSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_RippleMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.RippleMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).RippleMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/RippleMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).RippleMultiSign(ctx, req.(*common.RippleMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_OntSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.OntSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).OntSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/OntSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).OntSign(ctx, req.(*common.OntSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_OntMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.OntMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).OntMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/OntMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).OntMultiSign(ctx, req.(*common.OntMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_VolumeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.VolumeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).VolumeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/VolumeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).VolumeSign(ctx, req.(*common.VolumeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_EthLikeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EthLikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).EthLikeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/EthLikeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).EthLikeSign(ctx, req.(*EthLikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_Erc20LikeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Erc20LikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).Erc20LikeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/Erc20LikeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).Erc20LikeSign(ctx, req.(*Erc20LikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_AtomSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AtomSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).AtomSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/AtomSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).AtomSign(ctx, req.(*common.AtomSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_AtomMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AtomMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).AtomMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/AtomMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).AtomMultiSign(ctx, req.(*common.AtomMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_BnbSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AtomSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).BnbSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/BnbSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).BnbSign(ctx, req.(*common.AtomSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_BnbMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AtomMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).BnbMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/BnbMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).BnbMultiSign(ctx, req.(*common.AtomMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_PocSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AtomSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).PocSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/PocSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).PocSign(ctx, req.(*common.AtomSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_PocMultiSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AtomMultiSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).PocMultiSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/PocMultiSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).PocMultiSign(ctx, req.(*common.AtomMultiSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_MultiSignMsg_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.MultiSignMsgRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).MultiSignMsg(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/MultiSignMsg",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).MultiSignMsg(ctx, req.(*common.MultiSignMsgRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_AschLikeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.AschLikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).AschLikeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/AschLikeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).AschLikeSign(ctx, req.(*common.AschLikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_IotexLikeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.IotexLikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).IotexLikeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/IotexLikeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).IotexLikeSign(ctx, req.(*common.IotexLikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_Xrc20LikeSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Xrc20LikeSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).Xrc20LikeSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/Xrc20LikeSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).Xrc20LikeSign(ctx, req.(*common.Xrc20LikeSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Sign_XtzSign_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.XtzSignRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SignServer).XtzSign(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/sign.Sign/XtzSign",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SignServer).XtzSign(ctx, req.(*common.XtzSignRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Sign_serviceDesc = grpc.ServiceDesc{
	ServiceName: "sign.Sign",
	HandlerType: (*SignServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "UtxoSign",
			Handler:    _Sign_UtxoSign_Handler,
		},
		{
			MethodName: "EthSign",
			Handler:    _Sign_EthSign_Handler,
		},
		{
			MethodName: "EtcSign",
			Handler:    _Sign_EtcSign_Handler,
		},
		{
			MethodName: "Erc20Sign",
			Handler:    _Sign_Erc20Sign_Handler,
		},
		{
			MethodName: "UtxoMultiSign",
			Handler:    _Sign_UtxoMultiSign_Handler,
		},
		{
			MethodName: "EthMultiSign",
			Handler:    _Sign_EthMultiSign_Handler,
		},
		{
			MethodName: "Erc20MultiSign",
			Handler:    _Sign_Erc20MultiSign_Handler,
		},
		{
			MethodName: "EosLikeSign",
			Handler:    _Sign_EosLikeSign_Handler,
		},
		{
			MethodName: "EosLikeSingleSign",
			Handler:    _Sign_EosLikeSingleSign_Handler,
		},
		{
			MethodName: "TronSign",
			Handler:    _Sign_TronSign_Handler,
		},
		{
			MethodName: "RippleSign",
			Handler:    _Sign_RippleSign_Handler,
		},
		{
			MethodName: "RippleMultiSign",
			Handler:    _Sign_RippleMultiSign_Handler,
		},
		{
			MethodName: "OntSign",
			Handler:    _Sign_OntSign_Handler,
		},
		{
			MethodName: "OntMultiSign",
			Handler:    _Sign_OntMultiSign_Handler,
		},
		{
			MethodName: "VolumeSign",
			Handler:    _Sign_VolumeSign_Handler,
		},
		{
			MethodName: "EthLikeSign",
			Handler:    _Sign_EthLikeSign_Handler,
		},
		{
			MethodName: "Erc20LikeSign",
			Handler:    _Sign_Erc20LikeSign_Handler,
		},
		{
			MethodName: "AtomSign",
			Handler:    _Sign_AtomSign_Handler,
		},
		{
			MethodName: "AtomMultiSign",
			Handler:    _Sign_AtomMultiSign_Handler,
		},
		{
			MethodName: "BnbSign",
			Handler:    _Sign_BnbSign_Handler,
		},
		{
			MethodName: "BnbMultiSign",
			Handler:    _Sign_BnbMultiSign_Handler,
		},
		{
			MethodName: "PocSign",
			Handler:    _Sign_PocSign_Handler,
		},
		{
			MethodName: "PocMultiSign",
			Handler:    _Sign_PocMultiSign_Handler,
		},
		{
			MethodName: "MultiSignMsg",
			Handler:    _Sign_MultiSignMsg_Handler,
		},
		{
			MethodName: "AschLikeSign",
			Handler:    _Sign_AschLikeSign_Handler,
		},
		{
			MethodName: "IotexLikeSign",
			Handler:    _Sign_IotexLikeSign_Handler,
		},
		{
			MethodName: "Xrc20LikeSign",
			Handler:    _Sign_Xrc20LikeSign_Handler,
		},
		{
			MethodName: "XtzSign",
			Handler:    _Sign_XtzSign_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "sign.proto",
}

func init() { proto.RegisterFile("sign.proto", fileDescriptor_sign_39209a8238778a81) }

var fileDescriptor_sign_39209a8238778a81 = []byte{
	// 974 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0x5d, 0x73, 0xdb, 0x44,
	0x14, 0x1d, 0x39, 0x6e, 0x62, 0x5f, 0x3b, 0x6e, 0x59, 0x92, 0x54, 0x55, 0x4b, 0xc7, 0x93, 0xa1,
	0xd4, 0xbc, 0xd8, 0x60, 0x18, 0x3e, 0x0a, 0x0c, 0x4d, 0x32, 0x2a, 0x64, 0xda, 0x4e, 0x32, 0x22,
	0x30, 0x79, 0x63, 0x64, 0x69, 0xb1, 0x35, 0x91, 0x77, 0x8d, 0xb4, 0x2e, 0x36, 0xff, 0x86, 0x1f,
	0xc6, 0x1f, 0x80, 0x07, 0x66, 0x78, 0xe6, 0x81, 0xd9, 0xd5, 0x6a, 0xa5, 0xf5, 0xca, 0x74, 0x26,
	0x8d, 0x87, 0xa7, 0xe8, 0x9e, 0xb3, 0xf7, 0xec, 0xbd, 0x57, 0x67, 0x57, 0x31, 0x40, 0x1a, 0x8d,
	0x49, 0x7f, 0x96, 0x50, 0x46, 0x51, 0x9d, 0x3f, 0x3b, 0x1f, 0x8f, 0x23, 0xd6, 0x1f, 0x4d, 0xf0,
	0xa2, 0x1f, 0xd1, 0xc1, 0x2f, 0x7e, 0x1c, 0x63, 0x36, 0x08, 0xe8, 0x74, 0x4a, 0xc9, 0x40, 0x2c,
	0x4b, 0xf3, 0x28, 0xfb, 0x93, 0xe5, 0x3a, 0x5f, 0xbc, 0x36, 0x8b, 0xd1, 0x2b, 0x4c, 0x06, 0x2c,
	0x11, 0x99, 0x09, 0x1e, 0x5c, 0x24, 0x79, 0xf2, 0xe1, 0x3f, 0x16, 0xec, 0xf2, 0xf0, 0xbb, 0x68,
	0x4c, 0x3c, 0x3c, 0x8b, 0x97, 0xe8, 0x3d, 0xa8, 0x07, 0x34, 0xc4, 0xb6, 0xd5, 0xb5, 0x7a, 0x9d,
	0x21, 0xea, 0xcb, 0xbd, 0x3c, 0xcc, 0xe6, 0x09, 0x39, 0xa1, 0x21, 0xf6, 0x04, 0x8f, 0xee, 0xc0,
	0xd6, 0x34, 0x1d, 0xdb, 0xb5, 0xae, 0xd5, 0x6b, 0x7a, 0xfc, 0x11, 0x7d, 0x08, 0x0d, 0xde, 0x06,
	0x0e, 0x2f, 0x16, 0xf6, 0x56, 0xd7, 0xea, 0xb5, 0x86, 0xfb, 0xd9, 0x2e, 0x01, 0x8d, 0xfb, 0x17,
	0x89, 0x4f, 0x52, 0x3f, 0x60, 0x11, 0x25, 0x9e, 0x5a, 0x86, 0x9e, 0x42, 0x13, 0x2f, 0x18, 0x26,
	0x69, 0x44, 0x89, 0x5d, 0xef, 0x6e, 0xf5, 0x5a, 0xc3, 0xc3, 0xbe, 0x98, 0x8b, 0x56, 0x54, 0xdf,
	0xcd, 0x17, 0xb9, 0x84, 0x25, 0x4b, 0xaf, 0x48, 0x72, 0xbe, 0x84, 0x8e, 0x4e, 0xf2, 0xc2, 0xae,
	0xf0, 0x52, 0xd4, 0xdf, 0xf4, 0xf8, 0x23, 0xda, 0x83, 0x5b, 0xaf, 0xfc, 0x78, 0x8e, 0x65, 0xb1,
	0x59, 0xf0, 0xa4, 0xf6, 0x99, 0x75, 0xf8, 0xb7, 0x05, 0xb7, 0x8b, 0x9d, 0x7e, 0x9e, 0xe3, 0x94,
	0x21, 0x07, 0x1a, 0x3f, 0x25, 0x74, 0x7a, 0x14, 0x86, 0x89, 0x14, 0x51, 0x31, 0xe7, 0x66, 0x7e,
	0xc2, 0x70, 0x78, 0xfe, 0x5c, 0x88, 0xb5, 0x3d, 0x15, 0xa3, 0x47, 0x50, 0x7b, 0x5d, 0xe3, 0xb5,
	0x8b, 0x05, 0x3a, 0x36, 0x5b, 0x7e, 0x77, 0xb5, 0x65, 0x51, 0xc8, 0xc6, 0x9a, 0xfe, 0xbd, 0x06,
	0xc8, 0x65, 0x93, 0x17, 0xd1, 0x15, 0x2e, 0xf7, 0x8d, 0xa0, 0xce, 0xfb, 0x94, 0x1a, 0xe2, 0x19,
	0x75, 0xa0, 0xc6, 0xa8, 0x54, 0xa8, 0x31, 0x8a, 0x0e, 0x60, 0xdb, 0x9f, 0xd2, 0x39, 0x61, 0xa2,
	0xcf, 0xa6, 0x27, 0x23, 0xbe, 0x19, 0xa1, 0x24, 0xc0, 0x76, 0xbd, 0x6b, 0xf5, 0xea, 0x5e, 0x16,
	0xf0, 0x69, 0x8d, 0xfd, 0xf4, 0x3c, 0x89, 0x02, 0x6c, 0xdf, 0x12, 0x84, 0x8a, 0xd1, 0x43, 0x80,
	0x59, 0x12, 0xbd, 0xf2, 0x19, 0x7e, 0x8e, 0x97, 0xf6, 0xb6, 0x98, 0x65, 0x09, 0x41, 0xf7, 0xa0,
	0x21, 0x6c, 0xfb, 0x63, 0x14, 0xda, 0x3b, 0x62, 0xaf, 0x1d, 0x11, 0x9f, 0x86, 0x9c, 0x0a, 0x26,
	0x7e, 0x24, 0xa8, 0x46, 0x46, 0x89, 0xf8, 0x34, 0x44, 0x6e, 0x79, 0xb8, 0x4d, 0x31, 0xdc, 0xc7,
	0xd9, 0x70, 0xcd, 0x86, 0x37, 0x36, 0xdf, 0x3f, 0x2d, 0xb8, 0xa3, 0x6d, 0xf7, 0x66, 0xc7, 0xca,
	0x59, 0x39, 0x56, 0xed, 0xd2, 0xf9, 0x39, 0x31, 0xcd, 0xf4, 0xa8, 0xa2, 0xdf, 0x4d, 0x1e, 0xa1,
	0xdf, 0xb6, 0x60, 0xcf, 0x4d, 0x82, 0xe1, 0x07, 0xff, 0xaf, 0x9f, 0x0e, 0xa1, 0x2d, 0xfc, 0xc1,
	0x8f, 0x29, 0x4e, 0x53, 0xe1, 0xa8, 0xa6, 0xa7, 0x61, 0x3c, 0x3f, 0xc4, 0x41, 0x34, 0xf5, 0xe3,
	0x54, 0x78, 0xaa, 0xee, 0xa9, 0x78, 0xc5, 0x8f, 0x8d, 0xff, 0xf4, 0x63, 0x73, 0xbd, 0x1f, 0x41,
	0xf7, 0xe3, 0x37, 0xe5, 0xf7, 0xd3, 0x12, 0xef, 0xe7, 0x7d, 0xf9, 0x7e, 0x2a, 0x46, 0xb6, 0xb1,
	0x77, 0xf4, 0x97, 0x05, 0x68, 0x65, 0xc3, 0xcd, 0x79, 0xd2, 0x35, 0x3d, 0xf9, 0xb8, 0xb2, 0xe7,
	0x0d, 0xba, 0x72, 0xf8, 0x47, 0x07, 0xea, 0x7c, 0x17, 0xf4, 0x04, 0x1a, 0xdf, 0xb3, 0x05, 0x15,
	0xcf, 0x77, 0xf3, 0x0e, 0x73, 0x44, 0xce, 0xdd, 0xd9, 0x37, 0x09, 0x3e, 0x9f, 0x4f, 0x61, 0xc7,
	0x65, 0x13, 0x91, 0x7a, 0x90, 0xaf, 0x90, 0x40, 0x9e, 0xb9, 0x67, 0xe0, 0x2a, 0x31, 0xb8, 0x46,
	0xe2, 0x57, 0xd0, 0x14, 0x43, 0x12, 0xa9, 0xb6, 0x5a, 0x92, 0x43, 0x79, 0xf2, 0x41, 0x05, 0xc3,
	0xd3, 0x4f, 0x61, 0x97, 0x77, 0xf0, 0x72, 0x1e, 0xb3, 0x48, 0x48, 0x3c, 0x28, 0x37, 0xa6, 0xe0,
	0x5c, 0xc6, 0x59, 0xc3, 0x72, 0xa9, 0x67, 0xd0, 0x76, 0xd9, 0xa4, 0x50, 0xba, 0x5f, 0xaa, 0xd7,
	0x10, 0xba, 0x57, 0x4d, 0x72, 0x9d, 0x17, 0xd0, 0x11, 0x45, 0x16, 0x4a, 0xef, 0x68, 0xc5, 0x1b,
	0x5a, 0xf7, 0xd7, 0xd1, 0x5c, 0xed, 0x04, 0x5a, 0x2e, 0x4d, 0x73, 0x0b, 0x21, 0xd5, 0x40, 0x09,
	0xcc, 0x75, 0xec, 0x4a, 0x2e, 0x9b, 0xd2, 0x5b, 0x0a, 0x23, 0xe3, 0xf8, 0x4d, 0xa4, 0x3e, 0x81,
	0x46, 0xfe, 0xd5, 0x46, 0xfb, 0x95, 0x5f, 0x71, 0xe7, 0xed, 0x8a, 0xff, 0x67, 0xd0, 0x53, 0x00,
	0x2f, 0x9a, 0xcd, 0xe4, 0xde, 0x6a, 0x7c, 0x05, 0x96, 0x67, 0xdf, 0xad, 0xa2, 0xb8, 0xc2, 0x19,
	0xdc, 0xce, 0xa0, 0x62, 0xb0, 0x0f, 0xf5, 0xb5, 0xc6, 0x64, 0x1f, 0xac, 0xe5, 0xa5, 0x67, 0xcf,
	0x08, 0xd3, 0x3d, 0x2b, 0x01, 0xc3, 0xb3, 0x0a, 0x97, 0x4e, 0x39, 0x23, 0xac, 0xc2, 0x29, 0x65,
	0xd4, 0x70, 0x8a, 0x4e, 0xca, 0x99, 0xfc, 0x40, 0xe3, 0xf9, 0x74, 0x65, 0x26, 0x05, 0x66, 0xcc,
	0xa4, 0x4c, 0x71, 0x85, 0xaf, 0xa1, 0x55, 0xfa, 0xec, 0x21, 0x7b, 0xdd, 0x97, 0xdf, 0x39, 0xa8,
	0xfe, 0x46, 0x22, 0x17, 0x76, 0xb5, 0x3b, 0x0a, 0x39, 0xeb, 0x2f, 0x6b, 0xc7, 0x5e, 0x77, 0xa9,
	0xf1, 0x3b, 0xe7, 0x88, 0xd1, 0xa9, 0x7e, 0xe7, 0xe4, 0x88, 0x71, 0xe7, 0x14, 0x84, 0x3c, 0xc2,
	0x1c, 0xa8, 0x38, 0xc2, 0x1a, 0x6c, 0x1c, 0xe1, 0x15, 0x96, 0x4b, 0x7d, 0x0e, 0x3b, 0xc7, 0x64,
	0x74, 0xad, 0x2a, 0xbe, 0x85, 0xf6, 0x31, 0x19, 0xdd, 0x50, 0x11, 0xe7, 0x34, 0xb8, 0x6e, 0x11,
	0xe7, 0x34, 0xb8, 0x89, 0x22, 0x9e, 0x41, 0x5b, 0x21, 0x2f, 0xd3, 0x71, 0x61, 0xd1, 0x32, 0x6a,
	0x58, 0x54, 0x27, 0xa5, 0xce, 0x51, 0x1a, 0x14, 0x0e, 0x53, 0x3a, 0x65, 0xd4, 0xd0, 0xd1, 0x49,
	0xf9, 0x92, 0x4f, 0x29, 0xc3, 0x0b, 0x25, 0xa4, 0x5a, 0xd3, 0x60, 0xa3, 0xb5, 0x15, 0x56, 0x4a,
	0x5d, 0x6a, 0x96, 0x55, 0x52, 0x97, 0x55, 0xa6, 0x75, 0xd6, 0xb0, 0xf2, 0x06, 0xb8, 0x64, 0xbf,
	0xea, 0x37, 0x80, 0x04, 0x8c, 0x1b, 0x40, 0xe1, 0xb3, 0x78, 0x39, 0xda, 0x16, 0x3f, 0x76, 0x3e,
	0xfa, 0x37, 0x00, 0x00, 0xff, 0xff, 0x79, 0x6e, 0xa4, 0xf5, 0xd2, 0x0e, 0x00, 0x00,
}
